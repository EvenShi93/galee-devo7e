#include "Tx.h"
#include "RF_A7105.h"

#define BIND_COUNT 2500

const u8 TxFsA7105Regs[] = {
     -1,  0x42, 0x00, 0x14, 0x00,  -1 ,  -1 , 0x00, 0x00, 0x00, 0x00, 0x01, 0x21, 0x05, 0x00, 0x50,
    0x9e, 0x4b, 0x00, 0x02, 0x16, 0x2b, 0x12, 0x00, 0x62, 0x80, 0x80, 0x00, 0x0a, 0x32, 0xc3, 0x0f,
    0x13, 0xc3, 0x00,  -1,  0x00, 0x00, 0x3b, 0x00, 0x17, 0x47, 0x80, 0x03, 0x01, 0x45, 0x18, 0x00,
    0x01, 0x0f,  -1,
};

const u8 TxFsCh[16][16] = {
  {0x0a, 0x5a, 0x14, 0x64, 0x1e, 0x6e, 0x28, 0x78, 0x32, 0x82, 0x3c, 0x8c, 0x46, 0x96, 0x50, 0xa0},
  {0xa0, 0x50, 0x96, 0x46, 0x8c, 0x3c, 0x82, 0x32, 0x78, 0x28, 0x6e, 0x1e, 0x64, 0x14, 0x5a, 0x0a},
  {0x0a, 0x5a, 0x50, 0xa0, 0x14, 0x64, 0x46, 0x96, 0x1e, 0x6e, 0x3c, 0x8c, 0x28, 0x78, 0x32, 0x82},
  {0x82, 0x32, 0x78, 0x28, 0x8c, 0x3c, 0x6e, 0x1e, 0x96, 0x46, 0x64, 0x14, 0xa0, 0x50, 0x5a, 0x0a},
  {0x28, 0x78, 0x0a, 0x5a, 0x50, 0xa0, 0x14, 0x64, 0x1e, 0x6e, 0x3c, 0x8c, 0x32, 0x82, 0x46, 0x96},
  {0x96, 0x46, 0x82, 0x32, 0x8c, 0x3c, 0x6e, 0x1e, 0x64, 0x14, 0xa0, 0x50, 0x5a, 0x0a, 0x78, 0x28},
  {0x50, 0xa0, 0x28, 0x78, 0x0a, 0x5a, 0x1e, 0x6e, 0x3c, 0x8c, 0x32, 0x82, 0x46, 0x96, 0x14, 0x64},
  {0x64, 0x14, 0x96, 0x46, 0x82, 0x32, 0x8c, 0x3c, 0x6e, 0x1e, 0x5a, 0x0a, 0x78, 0x28, 0xa0, 0x50},
  {0x50, 0xa0, 0x46, 0x96, 0x3c, 0x8c, 0x28, 0x78, 0x0a, 0x5a, 0x32, 0x82, 0x1e, 0x6e, 0x14, 0x64},
  {0x64, 0x14, 0x6e, 0x1e, 0x82, 0x32, 0x5a, 0x0a, 0x78, 0x28, 0x8c, 0x3c, 0x96, 0x46, 0xa0, 0x50},
  {0x46, 0x96, 0x3c, 0x8c, 0x50, 0xa0, 0x28, 0x78, 0x0a, 0x5a, 0x1e, 0x6e, 0x32, 0x82, 0x14, 0x64},
  {0x64, 0x14, 0x82, 0x32, 0x6e, 0x1e, 0x5a, 0x0a, 0x78, 0x28, 0xa0, 0x50, 0x8c, 0x3c, 0x96, 0x46},
  {0x46, 0x96, 0x0a, 0x5a, 0x3c, 0x8c, 0x14, 0x64, 0x50, 0xa0, 0x28, 0x78, 0x1e, 0x6e, 0x32, 0x82},
  {0x82, 0x32, 0x6e, 0x1e, 0x78, 0x28, 0xa0, 0x50, 0x64, 0x14, 0x8c, 0x3c, 0x5a, 0x0a, 0x96, 0x46},
  {0x46, 0x96, 0x0a, 0x5a, 0x50, 0xa0, 0x3c, 0x8c, 0x28, 0x78, 0x1e, 0x6e, 0x32, 0x82, 0x14, 0x64},
  {0x64, 0x14, 0x82, 0x32, 0x6e, 0x1e, 0x78, 0x28, 0x8c, 0x3c, 0xa0, 0x50, 0x5a, 0x0a, 0x96, 0x46},
};

u32 TxFsId;
u8  TxFsChRow;
u8  TxFsChCol;
u8  TxFsChOff;

static int TxFsRfInit()
{
    int i;

    A7105_WriteID(0x5475c52a);
    for (i = 0; i < 0x33; i++)
        if((s8)TxFsA7105Regs[i] != -1)
            A7105_WriteReg(i, TxFsA7105Regs[i]);

    A7105_Strobe(A7105_STANDBY);

	//用500ms校准IF
	A7105CaliIf(500);

    //VCO Current Calibration
    A7105_WriteReg(0x24, 0x13); //Recomended calibration from A7105 Datasheet

    //VCO Bank Calibration
    A7105_WriteReg(0x26, 0x3b); //Recomended limits from A7105 Datasheet

	//用500ms校准0频点
	if(!A7105_CaliCh(0x00,500))	return 0;

	//用500ms校准A0频点
	if(!A7105_CaliCh(0xa0,500))	return 0;

    //Reset VCO Band calibration
    A7105_WriteReg(0x25, 0x08);

    A7105_SetPower(Model.RfPwr);

    A7105_Strobe(A7105_STANDBY);
    return 1;
}

static void TxFsBuildPacket(u8 init)
{
    int i;
    //-100% =~ 0x03e8
    //+100% =~ 0x07ca
    //Calculate:
    //Center = 0x5d9
    //1 %    = 5
    TxPacket[0] = init ? 0xaa : 0x55;
    TxPacket[1] = (TxFsId >>  0) & 0xff;
    TxPacket[2] = (TxFsId >>  8) & 0xff;
    TxPacket[3] = (TxFsId >> 16) & 0xff;
    TxPacket[4] = (TxFsId >> 24) & 0xff;
    for (i = 0; i < 8; i++)
    {
        if (i > Model.RfChNum)
        {
            TxPacket[5 + i*2] = 0;
            TxPacket[6 + i*2] = 0;
            continue;
        }
        s32 value = (s32)TxChValue[i] * 0x1f1 / STK_TRV + 0x5d9;
        if (value < 0)            value = 0;
        TxPacket[5 + i*2] = value & 0xff;
        TxPacket[6 + i*2] = (value >> 8) & 0xff;
    }
    
	//WLToys implemented some enhancements to the protocol for the v9x9 quads:
	//油门通道 
	//   bit 14 控制照相机 
	//   bit 15 控制照相机
	//   bit 13 控制灯光
    if(Model.RfChNum==4) //伟力判断
    {
        if(TxChValue[4] > 0)      TxPacket[10] |= 0x20;
        if(TxChValue[5] > 0)      TxPacket[10] |= 0x40;
        if(TxChValue[6] > 0)      TxPacket[10] |= 0x80;
    }    
}

static u16 TxFsCallback()
{
    if (TxBindCnt)
    {
        TxFsBuildPacket(1);
        A7105_WriteData(TxPacket, 21, 1);
        TxBindCnt--;
    }
    else
    {
        TxFsBuildPacket(0);
        A7105_WriteData(TxPacket, 21, TxFsCh[TxFsChRow][TxFsChCol]-TxFsChOff);
        TxFsChCol = (TxFsChCol + 1) % 16;
        if (! TxFsChCol) //Keep transmit power updated
            A7105_SetPower(Model.RfPwr);
    }
    return 1460;
}

static u8 TxFsInit(u8 bind)
{
	u8 i;
	
    SysTimerStop();
    
	for(i=0;i<5;i++)
	{
		A7105_Reset();
		usleep(100000);
		SysTimerWatchDogRst();
		if (TxFsRfInit())
		{	    
		    TxFsId = Model.RfId ? Model.RfId : TxRndId;
		    TxFsId%=999999;
		    
		    TxFsChRow = TxFsId % 16;
		    TxFsChCol = 0;
		    TxFsChOff = (TxFsId & 0xff) / 16;
		    
		    if (bind || ! Model.RfId)
		    {
		        TxBindCnt = BIND_COUNT;
		    }
		    else
		    {
		        TxBindCnt = 0;
		    }
		    SysTimerStart(2400, TxFsCallback);
		    return 1;
		}
	}
	return 0;	
}


u32 TxFsOpen(void)
{
	return TxFsInit(0);
}

u32 TxFsBind(void)
{
	return BIND_COUNT*TxFsInit(1);
}

void TxFsClose(void)
{
    SysTimerStop();
    A7105_Reset();
}
